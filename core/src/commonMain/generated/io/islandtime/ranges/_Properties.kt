//
// This file is auto-generated by 'tools:code-generator'
//
@file:JvmMultifileClass
@file:JvmName("RangesKt")

package io.islandtime.ranges

import io.islandtime.between
import io.islandtime.measures.Centuries
import io.islandtime.measures.Days
import io.islandtime.measures.Decades
import io.islandtime.measures.Hours
import io.islandtime.measures.Microseconds
import io.islandtime.measures.Milliseconds
import io.islandtime.measures.Minutes
import io.islandtime.measures.Months
import io.islandtime.measures.Nanoseconds
import io.islandtime.measures.Seconds
import io.islandtime.measures.Weeks
import io.islandtime.measures.Years
import io.islandtime.measures.centuries
import io.islandtime.measures.days
import io.islandtime.measures.decades
import io.islandtime.measures.hours
import io.islandtime.measures.microseconds
import io.islandtime.measures.milliseconds
import io.islandtime.measures.minutes
import io.islandtime.measures.months
import io.islandtime.measures.nanoseconds
import io.islandtime.measures.seconds
import io.islandtime.measures.weeks
import io.islandtime.measures.years
import io.islandtime.ranges.`internal`.throwUnboundedIntervalException
import kotlin.jvm.JvmMultifileClass
import kotlin.jvm.JvmName

/**
 * The number of days between the start and end of this range. A range is inclusive, so if the start
 * and end date are the same, the length will be one day.
 *
 * @throws UnsupportedOperationException if the range isn't bounded
 */
public val DateRange.lengthInDays: Days
  get() = when {
      isEmpty() -> 0.days
      isBounded() -> Days.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole weeks between the start and end of this range. 
 *
 * @throws UnsupportedOperationException if the range isn't bounded
 */
public val DateRange.lengthInWeeks: Weeks
  get() = when {
      isEmpty() -> 0.weeks
      isBounded() -> Weeks.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole months between the start and end of this range. 
 *
 * @throws UnsupportedOperationException if the range isn't bounded
 */
public val DateRange.lengthInMonths: Months
  get() = when {
      isEmpty() -> 0.months
      isBounded() -> Months.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole years between the start and end of this range. 
 *
 * @throws UnsupportedOperationException if the range isn't bounded
 */
public val DateRange.lengthInYears: Years
  get() = when {
      isEmpty() -> 0.years
      isBounded() -> Years.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole decades between the start and end of this range. 
 *
 * @throws UnsupportedOperationException if the range isn't bounded
 */
public val DateRange.lengthInDecades: Decades
  get() = when {
      isEmpty() -> 0.decades
      isBounded() -> Decades.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole centuries between the start and end of this range. 
 *
 * @throws UnsupportedOperationException if the range isn't bounded
 */
public val DateRange.lengthInCenturies: Centuries
  get() = when {
      isEmpty() -> 0.centuries
      isBounded() -> Centuries.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of nanoseconds between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInNanoseconds: Nanoseconds
  get() = when {
      isEmpty() -> 0.nanoseconds
      isBounded() -> Nanoseconds.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole microseconds between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInMicroseconds: Microseconds
  get() = when {
      isEmpty() -> 0.microseconds
      isBounded() -> Microseconds.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole milliseconds between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInMilliseconds: Milliseconds
  get() = when {
      isEmpty() -> 0.milliseconds
      isBounded() -> Milliseconds.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole seconds between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInSeconds: Seconds
  get() = when {
      isEmpty() -> 0.seconds
      isBounded() -> Seconds.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole minutes between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInMinutes: Minutes
  get() = when {
      isEmpty() -> 0.minutes
      isBounded() -> Minutes.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole hours between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInHours: Hours
  get() = when {
      isEmpty() -> 0.hours
      isBounded() -> Hours.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole days between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInDays: Days
  get() = when {
      isEmpty() -> 0.days
      isBounded() -> Days.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole weeks between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInWeeks: Weeks
  get() = when {
      isEmpty() -> 0.weeks
      isBounded() -> Weeks.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole months between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInMonths: Months
  get() = when {
      isEmpty() -> 0.months
      isBounded() -> Months.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole years between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInYears: Years
  get() = when {
      isEmpty() -> 0.years
      isBounded() -> Years.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole decades between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInDecades: Decades
  get() = when {
      isEmpty() -> 0.decades
      isBounded() -> Decades.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole centuries between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val DateTimeInterval.lengthInCenturies: Centuries
  get() = when {
      isEmpty() -> 0.centuries
      isBounded() -> Centuries.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole days between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val OffsetDateTimeInterval.lengthInDays: Days
  get() = when {
      isEmpty() -> 0.days
      isBounded() -> Days.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole weeks between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val OffsetDateTimeInterval.lengthInWeeks: Weeks
  get() = when {
      isEmpty() -> 0.weeks
      isBounded() -> Weeks.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole months between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val OffsetDateTimeInterval.lengthInMonths: Months
  get() = when {
      isEmpty() -> 0.months
      isBounded() -> Months.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole years between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val OffsetDateTimeInterval.lengthInYears: Years
  get() = when {
      isEmpty() -> 0.years
      isBounded() -> Years.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole decades between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val OffsetDateTimeInterval.lengthInDecades: Decades
  get() = when {
      isEmpty() -> 0.decades
      isBounded() -> Decades.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole centuries between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val OffsetDateTimeInterval.lengthInCenturies: Centuries
  get() = when {
      isEmpty() -> 0.centuries
      isBounded() -> Centuries.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole days between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val ZonedDateTimeInterval.lengthInDays: Days
  get() = when {
      isEmpty() -> 0.days
      isBounded() -> Days.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole weeks between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val ZonedDateTimeInterval.lengthInWeeks: Weeks
  get() = when {
      isEmpty() -> 0.weeks
      isBounded() -> Weeks.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole months between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val ZonedDateTimeInterval.lengthInMonths: Months
  get() = when {
      isEmpty() -> 0.months
      isBounded() -> Months.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole years between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val ZonedDateTimeInterval.lengthInYears: Years
  get() = when {
      isEmpty() -> 0.years
      isBounded() -> Years.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole decades between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val ZonedDateTimeInterval.lengthInDecades: Decades
  get() = when {
      isEmpty() -> 0.decades
      isBounded() -> Decades.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole centuries between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val ZonedDateTimeInterval.lengthInCenturies: Centuries
  get() = when {
      isEmpty() -> 0.centuries
      isBounded() -> Centuries.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of nanoseconds between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val TimePointInterval<*>.lengthInNanoseconds: Nanoseconds
  get() = when {
      isEmpty() -> 0.nanoseconds
      isBounded() -> Nanoseconds.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole microseconds between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val TimePointInterval<*>.lengthInMicroseconds: Microseconds
  get() = when {
      isEmpty() -> 0.microseconds
      isBounded() -> Microseconds.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole milliseconds between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val TimePointInterval<*>.lengthInMilliseconds: Milliseconds
  get() = when {
      isEmpty() -> 0.milliseconds
      isBounded() -> Milliseconds.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole seconds between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val TimePointInterval<*>.lengthInSeconds: Seconds
  get() = when {
      isEmpty() -> 0.seconds
      isBounded() -> Seconds.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole minutes between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val TimePointInterval<*>.lengthInMinutes: Minutes
  get() = when {
      isEmpty() -> 0.minutes
      isBounded() -> Minutes.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }

/**
 * The number of whole hours between the start and end of this interval. 
 *
 * @throws UnsupportedOperationException if the interval isn't bounded
 */
public val TimePointInterval<*>.lengthInHours: Hours
  get() = when {
      isEmpty() -> 0.hours
      isBounded() -> Hours.between(start, endExclusive)
      else -> throwUnboundedIntervalException()
  }
